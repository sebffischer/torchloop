// Generated by using torchexport::export() -> do not edit by hand
#include "lltm/lltm.h"
#include <lantern/types.h>
#include "lltm/lltm_types.h"
void * p_lltm_last_error = NULL;

LLTM_API void* lltm_last_error()
{
  return p_lltm_last_error;
}

LLTM_API void lltm_last_error_clear()
{
  p_lltm_last_error = NULL;
}

optim_sgd lltm_sgd (torch::TensorList params, double lr, double momentum, double dampening, double weight_decay, bool nesterov);
LLTM_API void* _lltm_sgd (void* params, double lr, double momentum, double dampening, double weight_decay, bool nesterov) {
  try {
    return  make_raw::SGD(lltm_sgd(from_raw::TensorList(params), lr, momentum, dampening, weight_decay, nesterov));
  } LLTM_HANDLE_EXCEPTION
  return (void*) NULL;
}
void lltm_sgd_step (optim_sgd opt);
LLTM_API void _lltm_sgd_step (void* opt) {
  try {
     (lltm_sgd_step(from_raw::SGD(opt)));
  } LLTM_HANDLE_EXCEPTION
  
}
void lltm_sgd_zero_grad (optim_sgd opt);
LLTM_API void _lltm_sgd_zero_grad (void* opt) {
  try {
     (lltm_sgd_zero_grad(from_raw::SGD(opt)));
  } LLTM_HANDLE_EXCEPTION
  
}
torch::Tensor lltm_run_script_module (graph_function network, graph_function loss_fn, torch::Tensor input, torch::Tensor target);
LLTM_API void* _lltm_run_script_module (void* network, void* loss_fn, void* input, void* target) {
  try {
    return  make_raw::Tensor(lltm_run_script_module(from_raw::GraphFunction(network), from_raw::GraphFunction(loss_fn), from_raw::Tensor(input), from_raw::Tensor(target)));
  } LLTM_HANDLE_EXCEPTION
  return (void*) NULL;
}
std::vector<torch::Tensor> lltm_forward (torch::Tensor input, torch::Tensor weights, torch::Tensor bias, torch::Tensor old_h, torch::Tensor old_cell);
LLTM_API void* _lltm_forward (void* input, void* weights, void* bias, void* old_h, void* old_cell) {
  try {
    return  make_raw::TensorList(lltm_forward(from_raw::Tensor(input), from_raw::Tensor(weights), from_raw::Tensor(bias), from_raw::Tensor(old_h), from_raw::Tensor(old_cell)));
  } LLTM_HANDLE_EXCEPTION
  return (void*) NULL;
}
std::vector<torch::Tensor> lltm_backward (torch::Tensor grad_h, torch::Tensor grad_cell, torch::Tensor new_cell, torch::Tensor input_gate, torch::Tensor output_gate, torch::Tensor candidate_cell, torch::Tensor X, torch::Tensor gate_weights, torch::Tensor weights);
LLTM_API void* _lltm_backward (void* grad_h, void* grad_cell, void* new_cell, void* input_gate, void* output_gate, void* candidate_cell, void* X, void* gate_weights, void* weights) {
  try {
    return  make_raw::TensorList(lltm_backward(from_raw::Tensor(grad_h), from_raw::Tensor(grad_cell), from_raw::Tensor(new_cell), from_raw::Tensor(input_gate), from_raw::Tensor(output_gate), from_raw::Tensor(candidate_cell), from_raw::Tensor(X), from_raw::Tensor(gate_weights), from_raw::Tensor(weights)));
  } LLTM_HANDLE_EXCEPTION
  return (void*) NULL;
}
void delete_optim_sgd (void* x);
LLTM_API void _delete_optim_sgd (void* x) {
  try {
     (delete_optim_sgd(x));
  } LLTM_HANDLE_EXCEPTION
  
}
void delete_graph_function (void* x);
LLTM_API void _delete_graph_function (void* x) {
  try {
     (delete_graph_function(x));
  } LLTM_HANDLE_EXCEPTION
  
}
void delete_stack2 (void* x);
LLTM_API void _delete_stack2 (void* x) {
  try {
     (delete_stack2(x));
  } LLTM_HANDLE_EXCEPTION
  
}
